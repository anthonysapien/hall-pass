#!/usr/bin/env bun

/**
 * hall-pass: PreToolUse hook for Claude Code
 *
 * Routes by tool type:
 *   - Bash: unified recursive evaluation via evaluateBashCommand
 *   - Write/Edit: file path protection
 *
 * Decision protocol (all exit 0 + JSON on stdout):
 *   { permissionDecision: "allow" }                = auto-approve (skip prompt)
 *   { permissionDecision: "ask" }                  = prompt user for permission
 *   { permissionDecision: "ask", additionalContext } = prompt user + nudge Claude
 */

// Diagnostic log — always writes to /tmp so we can debug hook failures
const DIAG = "/tmp/hall-pass-diag.log"
function diag(msg: string) {
  try { require("fs").appendFileSync(DIAG, `${new Date().toISOString()} ${msg}\n`) } catch {}
}

/** Output a permissionDecision JSON to stdout and exit. */
function allow(reason: string): never {
  diag(`ALLOW ${reason}`)
  const output = JSON.stringify({
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      permissionDecision: "allow",
      permissionDecisionReason: reason,
    },
  })
  process.stdout.write(output)
  process.exit(0)
}

/** Prompt the user while nudging Claude with feedback via additionalContext. */
function feedback(suggestion: string): never {
  diag(`FEEDBACK ${suggestion}`)
  const output = JSON.stringify({
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      permissionDecision: "ask",
      additionalContext: suggestion,
    },
  })
  process.stdout.write(output)
  process.exit(0)
}

/** Prompt the user for permission (no additional context for Claude). */
function prompt(reason: string): never {
  diag(`PROMPT ${reason}`)
  const output = JSON.stringify({
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      permissionDecision: "ask",
    },
  })
  process.stdout.write(output)
  process.exit(0)
}

import { extractCommandInfos, extractRedirects } from "./parser.ts"
import { loadConfig } from "./config.ts"
import { createDebug } from "./debug.ts"
import { createAudit } from "./audit.ts"
import { checkFilePath } from "./paths.ts"
import { checkFeedbackRules } from "./feedback.ts"
import { createEvalContext } from "./evaluate.ts"

// -- Read hook input from stdin --

diag("start")
let toolName: string
let toolInput: Record<string, unknown>
try {
  const input = await Bun.stdin.text()
  const parsed = JSON.parse(input)
  toolName = parsed?.tool_name ?? ""
  toolInput = parsed?.tool_input ?? {}
} catch (e) {
  diag(`stdin-error: ${e}`)
  process.exit(1)
}

const command = (toolInput.command as string) ?? ""
diag(`tool=${toolName} cmd=${command.slice(0, 80)}`)

// -- Load config + initialize debug/audit --

const config = await loadConfig()

const debug = createDebug(config)
const audit = createAudit(config)

debug("input", { toolName, toolInput })

// -- Route by tool type --

if (toolName === "Write" || toolName === "Edit") {
  const filePath = toolInput.file_path as string
  if (!filePath) {
    debug("write/edit", "no file_path, allowing")
    allow("write/edit no path")
  }

  debug("write/edit", { filePath })
  const decision = checkFilePath(filePath, "write", config)
  debug("path-check", decision)

  if (!decision.allowed) {
    audit.log({ tool: toolName, input: filePath, decision: "prompt", reason: decision.reason, layer: "paths" })
    prompt(`path-blocked: ${decision.reason}`)
  }

  audit.log({ tool: toolName, input: filePath, decision: "allow", reason: "no path match", layer: "paths" })
  allow("write/edit allowed")
}

// -- Bash path --

if (!command) {
  debug("bash", "empty command")
  prompt("empty command")
}

debug("bash", { command })

// -- Parse with shfmt --

const proc = Bun.spawn(["shfmt", "--tojson"], {
  stdin: new Response(command),
  stdout: "pipe",
  stderr: "pipe",
})

const stdout = await new Response(proc.stdout).text()
await proc.exited

if (proc.exitCode !== 0) {
  debug("shfmt", "parse failed")
  prompt("shfmt failed")
}

let ast: unknown
try {
  ast = JSON.parse(stdout)
} catch {
  debug("shfmt", "JSON parse failed")
  prompt("shfmt json failed")
}

// -- Extract commands and AST-level data --

const commandInfos = extractCommandInfos(ast)
debug("commands", commandInfos.map(c => c.name))

// -- AST-level checks (not per-command) --

// Redirects against protected paths
const redirects = extractRedirects(ast)
debug("redirects", redirects)

for (const redir of redirects) {
  const op = redir.op === "write" ? "write" as const : "read" as const
  const decision = checkFilePath(redir.path, op, config)
  if (!decision.allowed) {
    debug("redirect-block", { path: redir.path, op, reason: decision.reason })
    audit.log({ tool: "Bash", input: command, decision: "prompt", reason: `redirect ${decision.reason}`, layer: "paths" })
    prompt(`redirect-blocked: ${decision.reason}`)
  }
}

// Pipeline-level feedback rules (cross-command patterns)
const feedbackSuggestion = checkFeedbackRules(commandInfos)
if (feedbackSuggestion) {
  debug("feedback", { suggestion: feedbackSuggestion })
  audit.log({ tool: "Bash", input: command, decision: "feedback", reason: feedbackSuggestion, layer: "feedback" })
  feedback(feedbackSuggestion)
}

// No commands found (e.g., bare variable assignment) — safe
if (commandInfos.length === 0) {
  audit.log({ tool: "Bash", input: command, decision: "allow", reason: "no commands", layer: "safelist" })
  allow("no commands (variable assignment)")
}

// -- Per-command evaluation --

const ctx = createEvalContext(config, commandInfos)

for (const cmdInfo of commandInfos) {
  const result = ctx.evaluate(cmdInfo)
  debug("eval", { name: cmdInfo.name, decision: result.decision })

  if (result.decision === "feedback") {
    audit.log({ tool: "Bash", input: command, decision: "feedback", reason: result.suggestion, layer: "evaluate" })
    feedback(result.suggestion)
  }

  if (result.decision === "prompt") {
    audit.log({ tool: "Bash", input: command, decision: "prompt", reason: result.reason, layer: "evaluate" })
    prompt(result.reason)
  }
}

audit.log({ tool: "Bash", input: command, decision: "allow", reason: "all commands safe", layer: "evaluate" })
allow("all commands safe")
